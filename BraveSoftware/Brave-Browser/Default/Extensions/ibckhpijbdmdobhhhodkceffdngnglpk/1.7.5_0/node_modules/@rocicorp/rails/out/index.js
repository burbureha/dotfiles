import { __exports as out } from '../../../../node_modules/_virtual/index4.js';
export { __exports as default } from '../../../../node_modules/_virtual/index4.js';
import '../../../zod/lib/index.js';
import { __exports as lib } from '../../../../node_modules/_virtual/index5.js';

Object.defineProperty(out, "__esModule", {
  value: true
});
var entitySchema = out.entitySchema = generate_1 = out.generate = out.parseIfDebug = void 0;

const zod_1 = lib;

function parseIfDebug(schema, val) {
  var _a, _b;

  if (((_b = (_a = globalThis.process) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.NODE_ENV) !== 'production') {
    return schema.parse(val);
  }

  return val;
}

out.parseIfDebug = parseIfDebug;

function generate(prefix, schema, logger = console) {
  return {
    put: (tx, value) => putImpl(prefix, schema, tx, value),
    init: (tx, value) => initImpl(prefix, schema, tx, value),
    update: (tx, update) => updateImpl(prefix, schema, tx, update, logger),
    delete: (tx, id) => deleteImpl(prefix, tx, id),
    has: (tx, id) => hasImpl(prefix, tx, id),
    get: (tx, id) => getImpl(prefix, schema, tx, id),
    mustGet: (tx, id) => mustGetImpl(prefix, schema, tx, id),
    list: (tx, options) => listImpl(prefix, schema, tx, options)
  };
}

var generate_1 = out.generate = generate;
entitySchema = out.entitySchema = zod_1.z.object({
  id: zod_1.z.string()
});

function key(prefix, id) {
  return `${prefix}/${id}`;
}

async function initImpl(prefix, schema, tx, initial) {
  const val = parseIfDebug(schema, initial);
  const k = key(prefix, val.id);

  if (await tx.has(k)) {
    return false;
  }

  await tx.put(k, val);
  return true;
}

async function putImpl(prefix, schema, tx, initial) {
  const val = parseIfDebug(schema, initial);
  await tx.put(key(prefix, val.id), val);
}

async function hasImpl(prefix, tx, id) {
  return await tx.has(key(prefix, id));
}

async function getImpl(prefix, schema, tx, id) {
  return await getInternal(schema, tx, key(prefix, id));
}

async function mustGetImpl(prefix, schema, tx, id) {
  const v = await getInternal(schema, tx, key(prefix, id));

  if (v === undefined) {
    throw new Error(`no such entity ${id}`);
  }

  return v;
}

async function updateImpl(prefix, schema, tx, update, logger) {
  var _a;

  const {
    id
  } = update;
  const k = key(prefix, id);
  const prev = await getInternal(schema, tx, k);

  if (prev === undefined) {
    (_a = logger.debug) === null || _a === void 0 ? void 0 : _a.call(logger, `no such entity ${id}, skipping update`);
    return;
  }

  const next = { ...prev,
    ...update
  };
  const parsed = parseIfDebug(schema, next);
  await tx.put(k, parsed);
}

async function deleteImpl(prefix, tx, id) {
  await tx.del(key(prefix, id));
}

async function listImpl(prefix, schema, tx, options) {
  const {
    startAtID,
    limit
  } = options !== null && options !== void 0 ? options : {};
  const result = [];

  for await (const v of tx.scan({
    prefix: key(prefix, ''),
    start: {
      key: key(prefix, startAtID !== null && startAtID !== void 0 ? startAtID : '')
    },
    limit
  }).values()) {
    const parsed = parseIfDebug(schema, v);
    result.push(parsed);
  }

  return result;
}

async function getInternal(schema, tx, key) {
  const val = await tx.get(key);

  if (val === undefined) {
    return val;
  } // TODO: parse only in debug mode


  const parsed = parseIfDebug(schema, val);
  return parsed;
}

export { entitySchema, generate_1 as generate };
