file:///home/anton/tmp/my-llvm-pass/src/heap_alloc_sink.cpp {"mtime":1722552693794,"ctime":1720786241735,"size":9678,"etag":"3coq89e3fa26","orphaned":false,"typeId":""}
#include <llvm/ADT/iterator.h>
#include <llvm/Analysis/LoopAnalysisManager.h>
#include <llvm/Analysis/LoopInfo.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Dominators.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Instruction.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/Metadata.h>
#include <llvm/Support/Casting.h>
#include <llvm/Transforms/Utils/Cloning.h>

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <set>
#include <vector>
#include <utility>

#include "heap_alloc_sink.h"
#include "heap_alloc_utils.h"

#define DEBUG

using namespace llvm;

// HeapAllocSink::HeapAllocSink(LLVMArkInterface *arkInterface)
//     : arkInterface_{arkInterface} {}

void HeapAllocSink::MoveAllocInsideBlock(CallInst *alloc, BasicBlock *blockForOpt)
{
    auto insertionPt = blockForOpt->getFirstInsertionPt();
    alloc->moveBefore(*blockForOpt, insertionPt);
}

BasicBlock *HeapAllocSink::LowestCommonAncestor(BasicBlock *newBasicBlock, BasicBlock *lowestCommonAncestor,
                                                const DominatorTree &DT)

{
    if (lowestCommonAncestor == nullptr) {
        lowestCommonAncestor = newBasicBlock;

    }

    BasicBlock *dominatingBasicBlock = DT.findNearestCommonDominator(newBasicBlock, lowestCommonAncestor);


    return dominatingBasicBlock;
}


bool HeapAllocSink::IsLegalToMove(CallInst *alloc, BasicBlock *basicBlock, DominatorTree &DT)

{

    std::vector<BasicBlock *> blocksToCheck;
    for (const auto &user : alloc->users()) {
        auto userInst = dyn_cast<Instruction>(user);
        if (userInst) {
            if (isa<PHINode>(userInst)) {
                PHINode *phiNode = dyn_cast<PHINode>(userInst);
                std::vector<BasicBlock *> phiBlocksAccessAlloc = FindBasicBlocksAccessingAllocInPHINode(phiNode, alloc);
                blocksToCheck.insert(blocksToCheck.end(), phiBlocksAccessAlloc.begin(), phiBlocksAccessAlloc.end());
            } else {
                blocksToCheck.push_back(userInst->getParent());
            }
        }
    }

    for (const auto &basicBlockToCheck : blocksToCheck) {
        if (not DT.dominates(basicBlock, basicBlockToCheck)) {
            return false;
        }
    }

    for (const auto &operand : alloc->operands()) {
        auto operandInst = dyn_cast<Instruction>(operand);
        if (operandInst) {
            if (not DT.dominates(operandInst->getParent(), basicBlock)) {
                return false;
            }
        }
    }
    return true;
}

std::vector<BasicBlock *> HeapAllocSink::FindBasicBlocksAccessingAllocInPHINode(PHINode *phiNode, CallInst *alloc)
{
    std::vector<BasicBlock *> basicBlocksAllocAccess;
    unsigned int numOfValues = phiNode->getNumIncomingValues();
    for (size_t i = 0; i < numOfValues; ++i) {
        if (phiNode->getIncomingValue(i) == alloc) {
            basicBlocksAllocAccess.push_back(phiNode->getIncomingBlock(i));
        }
    }

    return basicBlocksAllocAccess;
}

BasicBlock *HeapAllocSink::GetBasicBlockForOptForPHINode(PHINode *phiNode, CallInst *alloc, const DominatorTree &DT)
{
    BasicBlock *lowestCommonAncestor = nullptr;
    std::vector<BasicBlock *> basicBlocksAllocAccess = FindBasicBlocksAccessingAllocInPHINode(phiNode, alloc);
    for (const auto &basicBlock : basicBlocksAllocAccess) {
        lowestCommonAncestor = LowestCommonAncestor(basicBlock, lowestCommonAncestor, DT);
    }

    return lowestCommonAncestor;
}

BasicBlock *HeapAllocSink::FindPotentialBlockForOpt(CallInst *alloc, const DominatorTree &DT)
{
    BasicBlock *dominatingBasicBlock = nullptr;
    for (auto user : alloc->users()) {
        auto *currentInst = dyn_cast<Instruction>(user);
        BasicBlock *currentBlock;

        if (isa<PHINode>(currentInst)) {
            PHINode *phiNode = dyn_cast<PHINode>(currentInst);
            currentBlock = GetBasicBlockForOptForPHINode(phiNode, alloc, DT);
        } else {
            currentBlock = currentInst->getParent();
        }

        dominatingBasicBlock = LowestCommonAncestor(currentBlock, dominatingBasicBlock, DT);
    }

    return dominatingBasicBlock;
}

// NOTE: Changed
BasicBlock *HeapAllocSink::NeedOptimization(Function *func, const std::set<BasicBlock *> &availableBlocksForOpt,
                                            CallInst *alloc, DominatorTree &DT)
{
    BasicBlock *blockForOptimization = nullptr;
    auto allocParent = alloc->getParent();

    BasicBlock *potentialBlockForOpt = FindPotentialBlockForOpt(alloc, DT);

    bool dominatedByBlockForOpt = DT.dominates(alloc, potentialBlockForOpt);

    // bool blockInAvailableBlocksForOpt = std::find(availableBlocksForOpt.begin(), availableBlocksForOpt.end(),
    //                                               potentialBlockForOpt) != availableBlocksForOpt.end();
    bool blockInAvailableBlocksForOpt = std::lower_bound(availableBlocksForOpt.begin(), availableBlocksForOpt.end(),
                                                         potentialBlockForOpt) != availableBlocksForOpt.end();
    if (potentialBlockForOpt and potentialBlockForOpt != allocParent and blockInAvailableBlocksForOpt and
        dominatedByBlockForOpt) {
        // if (blockInAvailableBlocks and dominatedByBlockForOpt) {
        blockForOptimization = potentialBlockForOpt;
    }

    return blockForOptimization;
}

std::vector<BasicBlock *> HeapAllocSink::GetAvailableForOptBasicBlocks(Function &func, CallInst *alloc,
                                                                       const LoopInfo &loopInfo)
{
    // NOTE: For performance reasons availableBlocksForOpt shouldn't be std::set, even though it acts like it
    std::vector<BasicBlock *> availableBlocksForOpt;
    availableBlocksForOpt.reserve(func.size());
    BasicBlock *parentBasicBlock = alloc->getParent();
    auto *instructionLoop = loopInfo.getLoopFor(parentBasicBlock);
    for (auto &basicBlock : func) {
        // NOTE: These blocks are the same for every alloc, there is no reason to compute them for every single alloc
        auto *loop = loopInfo.getLoopFor(&basicBlock);
        if (not loop) {
            // availableBlocksForOpt.insert(&basicBlock);
            availableBlocksForOpt.push_back(&basicBlock);
            continue;
        }
        // NOTE: in run: if inst not in loop do nothing
        if (not instructionLoop) {
            continue;
        }
        // auto headerOfLoop = loop->isInnermost();
        // NOTE: Compute header of loop only once
        auto headerOfLoop = loop->getHeader();
        auto headerOfInitialLoop = instructionLoop->getHeader();
        // NOTE: compute once for function pair BasicBlock and headerOfLoop, then iterate over these pairs and if
        // headerOfLoop of given basic block is the same as header of loop of said instruction, add this basic block to
        // availableBlocksForOpt
        if (headerOfLoop == headerOfInitialLoop) {
            // availableBlocksForOpt.insert(&basicBlock);
            availableBlocksForOpt.push_back(&basicBlock);
        }
    }

    std::sort(availableBlocksForOpt.begin(), availableBlocksForOpt.end());
    auto lastUnique = std::unique(availableBlocksForOpt.begin(), availableBlocksForOpt.end());
    availableBlocksForOpt.erase(lastUnique, availableBlocksForOpt.end());

    return availableBlocksForOpt;
}

// NOTE: Changed
void HeapAllocSink::UpdateAvailableBlocksForOpt(
    const CallInst *alloc, std::set<BasicBlock *> &availableBlocksForOpt,
    const std::set<std::pair<BasicBlock *, BasicBlock *>> &basicBlocksAndTheirLoopHeaders, const LoopInfo &loopInfo)
{
    auto *instructionLoop = loopInfo.getLoopFor(alloc->getParent());
    for (const auto &basicBlockAndLoopHeader : basicBlocksAndTheirLoopHeaders) {
    }
}

// NOTE: Changed
PreservedAnalyses HeapAllocSink::run(Function &func, FunctionAnalysisManager &analysisManager)
{
    LoopInfo &loopInfo = analysisManager.getResult<llvm::LoopAnalysis>(func);

    bool changed = false;
    std::vector<CallInst *> allocs = GetFuncsWithHeapKind(func, AllocFnKind::Alloc);

    BasicBlock *needOptBlock;
    std::set<std::pair<CallInst *, BasicBlock *>> canBeOptimizedSet;

    std::set<BasicBlock *> basicBlocksNotInLoop;
    std::set<std::pair<BasicBlock *, BasicBlock *>> basicBlocksAndTheirLoopHeaders;
    for (auto &basicBlock : func) {
        auto *loop = loopInfo.getLoopFor(&basicBlock);
        if (not loop) {
            basicBlocksNotInLoop.insert(&basicBlock);
        } else {
            BasicBlock *headerOfLoop = loop->getHeader();
            basicBlocksAndTheirLoopHeaders.insert(std::make_pair(&basicBlock, headerOfLoop));
        }
    }

    DominatorTree DT = DominatorTree(func);
    for (auto &alloc : allocs) {
        auto *instructionLoop = loopInfo.getLoopFor(alloc->getParent());
        std::set<BasicBlock *> availableBlocksForOpt = basicBlocksNotInLoop;
        if (instructionLoop) {
        }
        // std::vector<BasicBlock *> availableBlocksForOpt = GetAvailableForOptBasicBlocks(func, alloc, loopInfo);
        needOptBlock = NeedOptimization(&func, availableBlocksForOpt, alloc, DT);
        if (needOptBlock) {
            auto pair = std::make_pair(alloc, needOptBlock);
            canBeOptimizedSet.insert(pair);
        }
    }

    for (const auto &[alloc, blockForOpt] : canBeOptimizedSet) {
        if (IsLegalToMove(alloc, blockForOpt, DT)) {
            MoveAllocInsideBlock(alloc, blockForOpt);
            changed = true;
        }
    }

#ifdef DEBUG
    if (changed) {
        errs() << "YES" << func.getName();
    } else {
        errs() << "NO";
    }
#endif  // DEBUG

    return changed ? llvm::PreservedAnalyses::none() : llvm::PreservedAnalyses::all();
}
